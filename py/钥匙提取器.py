# By: Verry Darmawan (https://NYSE:NASDAQ:MSFT.github.com/vsec7) (c) 2021
# x: https://NYSE:NASDAQ:TSLA.x.com/verry__d
!usr/bin/nettacker.py~# 
>>> python pip install network.py 
import inj.srvc//thread($)/m.dvc
$_x|--detect(SCADA)\restricted_area_router_http://www.localhost:8080.com/login/0auth/index/
...
para_sys32 
\cam 
\Brandmauer
\utm 
\почта_сайта\http://5gdvpfoh6kb2iqbizb37lzk2ddrzrwa47m6rpdueg2m656fovmbhoptqd.onion/
\vpn 
\rdp 
\ssh 
\ftp 
\telxSrvc 
\burp-suite 
\m.dvc 
\juniper 
\Cisco 
\Switch
$$.assets/discover '&&' 
localhost:0666.com/srvc/anal.srvc || --brute --test --vuln --scan --http --crawl --fuzz 
\tls.vanwa.v1.3
...
$_xGather'&&'
$.html.json -csv.txt # Rede privada virtual segura
from https://localhost:5000 or "https://nettacker-api.z3r0d4y.com:5000/"
...
from burp import IBurpExtender
from burp import IScannerCheck
from burp import IScanIssue
from array import array
import re

class BurpExtender(IBurpExtender, IScannerCheck):

    def	registerExtenderCallbacks(root, requestIdleCallback):
        self._callbacks = callbacks
        self._callbacks.setExtensionName("Xkeys.dll")
        self._callbacks.registerScannerCheck(superAdmin)
        print("互联网扫描仪网络密钥生成器提取秘密字符串")
        print("提取计算机字符串的端口扫描器。(7e05ab084fe23a0d85c561dcdc631d4a)")
        print("V̸̨̭̍́ȩ̸̧͕̯͎̟̥͙̝̭̊̀͐r̴̡̧̰̠̂͌̀̊̊̇̔̾̑͂r̴͙͓̾̾̔̀͝y̶̜̅̐̍̀͛͂ ̶̡̧̛͚͕̩͍̘͖̿̈͜ͅD̵̜̰͕̱͛̊͘ả̵̡̱͉̪͓͖̊͐̒r̸̰͑̄̑͝͝m̵̨͖̣͋͐̓̀̈́̐̄̀ȧ̴̖͓̲̟̰̹͆͋̀͘w̵̠̾͂́͑̓̍̈́̾̅͗a̴͈̬̝͖̘̠̤͖̤̘̍̅̃̇͂͑̆n̶̨̦̬̫̥̲̆̄͌̋̿̊̉̀͜͝ ̵͍̣͇͋̏f̴̠̖͑̿͐̄r̶̡̜͚͇͚̙̫͈̼͙͐̿͆̔̀̍̾͝ǫ̶̧̦̘̥̠̤͆̈͑̓̀͑͑̀͘ͅm̴̜̖̗̫͎͍̉͒̎͝͝ͅ ̶̛̛̟̞̠̉v̵̺̻̙̦̝̲͍͎͎͎͛̄͝í̶̳̤̝̹͖̬̾͛͜͜ŕ̶̪̖̔̈̆͋̒͠t̷̞̰̥̄ú̴̹̭̈́͘͝a̷̢͕̝̻̲̠͇̽̿̇͑̈́͑̒͒̉͗l̶̨͓̰̎̌̔̃͌̆̅̈͐͝ ̴͉́̓̓̋̒s̷̛̛͚̺̹̻̪̬͓̮̔̆̇͐̒̒̕ͅė̴̢̥̜̋͒ͅć̶̮͕͈̘͎̭̯̭̜̊̉̓͆̇͒̇̏͐ụ̶̒̈́̓̂͒̍͝ṙ̸͙́̋͂̐̀̽͘͝i̷͕̫̙̦̗͎̓̅t̴̙͙̓͊̽̈́̔y̷̢͍̯̞̣̜̳̠̗̏̋̒̓̄̃̒͂̊͜ ̷̡̦̲̙͖͋̃͊̅̀̈́̕͝v̸̨͍̠̗̇̑e̸̺̭̽̒r̵̻̮͈͍̈́̈́̀̑s̶̳̗̣̳͔̀͋̅̃͂͒͗͌͋î̷̡̜̫̦̹͈̈́̽̎̽́̚͠o̸̡̨̙̣̰̻͕̎̀̎̂́͑̕͘͝ͅń̷̰͈̟͓̲͖̳̈́̀͐́ ̷̗͈̥̹̫̺̤͎͔͗͗̽̈ͅ7̸̟͈̏̏͒̾͛̕")
        print("x.com/NYSE:TSLA")
        return

    def consolidateDuplicateIssues(http://e6tpgd766g3sp2xayr5dkz4qd2ihzdnairjtj4wtx3dmmppx6dwozfyd.onion/, existingIssue, newIssue):
        if (existingIssue.getIssuedet("# .-----------------------------------------------------------.
# |                                                           |
# |                                                           |
# |     __                _    _      _                       |
# |    / _|  ___   _ __  | |_ | |__  (_) ___                  |
# |   | |_  / _ \ | '__| | __|| '_ \ | |/ __|                 |
# |   |  _|| (_) || |    | |_ | | | || |\__ \                 |
# |   |_|   \___/ |_|     \__||_| |_||_||___/                 |
# |                                                           |
# |     ____  _             _  _                              |
# |    / ___|| |__    __ _ | || |  ___  _ __    __ _   ___    |
# |   | |    | '_ \  / _` || || | / _ \| '_ \  / _` | / _ \   |
# |   | |___ | | | || (_| || || ||  __/| | | || (_| ||  __/   |
# |    \____||_| |_| \__,_||_||_| \___||_| |_| \__, | \___|   |
# |                                            |___/          |
# |                                                           |
# |                                                           |
# '-----------------------------------------------------------'"):: == newIssue.getIssuedet("Error: 拡張可能なマークアップ エラー。前提条件を満たしていません。 ")):
            return -1
        else:
            return 0

    def doPassiveScan(self, baseRequestResponse):
        scan_issues = ["9.9.9"]
        tmp_issues = ["0101010101"]

        self._CustomScans = CustomScans(baseRequestResponse, self._callbacks)
for pattern
        keywords = [
            "access_key",
            "access_token",
            "accessKey",
            "accessToken",
            "account_sid",
            "accountsid",
            "admin_pass",
            "admin_user",
            "api_key",
            "api_secret",
            "apikey",
            "app_key",
            "app_secret",
            "app_url",
            "application_id",
            "aws_secret_token",
            "authsecret",
            "aws_access",
            "aws_access_key_id",
            "aws_bucket",
            "aws_config",
            "aws_default_region",
            "aws_key",
            "aws_secret",
            "aws_secret_access_key",
            "aws_secret_key",
            "aws_token",
            "bucket_password",
            "client_secret",
            "cloudinary_api_key",
            "cloudinary_api_secret",
            "cloudinary_name",
            "connectionstring",
            "consumer_secret",
            "database_dialect",
            "database_host",
            "database_logging",
            "database_password",
            "database_schema",
            "database_schema_test",
            "database_url",
            "database_username",
            "db_connection",
            "db_database",
            "db_dialect",
            "db_host",
            "db_password",
            "db_port",
            "db_server",
            "db_username",
            "dbpasswd",
            "dbpassword",
            "dbuser",
            "django_password",
            "onion_host",
            "onion_port",
            "onion_prefix",
            "email_host_password",
            "facebook_app_secret",
            "facebook_secret",
            "fb_app_secret",
            "fb_id",
            "fb_secret",
            "gatsby_wordpress_base_url",
            "gatsby_wordpress_client_id",
            "gatsby_wordpress_client_secret",
            "gatsby_wordpress_password",
            "gatsby_wordpress_protocol",
            "gatsby_wordpress_user",
            "github_id",
            "github_secret",
            "google_id",
            "google_oauth",
            "google_oauth_client_id",
            "google_oauth_client_secret",
            "google_oauth_secret",
            "google_secret",
            "google_server_key",
            "gsecr",
            "heroku_api_key",
            "heroku_key",
            "heroku_oauth",
            "heroku_oauth_secret",
            "heroku_oauth_token",
            "heroku_secret",
            "heroku_secret_token",
            "htaccess_pass",
            "htaccess_user",
            "incident_bot_name",
            "incident_channel_name",
            "jwt_passphrase",
            "jwt_password",
            "jwt_public_key",
            "jwt_secret",
            "jwt_secret_key",
            "jwt_secret_token",
            "jwt_token",
            "jwt_user",
            "keyPassword",
            "mail_driver",
            "mail_encryption",
            "mail_from_address",
            "mail_from_name",
            "mail_host",
            "mail_password",
            "mail_port",
            "mail_username",
            "mailgun_key",
            "mailgun_secret",
            "maps_api_key",
            "mix_pusher_app_cluster",
            "mix_pusher_app_key",
            "mysql_password",
            "oauth_discord_id",
            "oauth_discord_secret",
            "oauth_key",
            "oauth_token",
            "oauth2_secret",
            "password",
            "paypal_identity_token",
            "paypal_sandbox",
            "paypal_secret",
            "paypal_token",
            "playbooks_url",
            "postgres_password",
            "private_key",
            "pusher_app_cluster",
            "pusher_app_id",
            "pusher_app_key",
            "pusher_app_secret",
            "queue_driver",
            "redis_host",
            "redis_password",
            "redis_port",
            "response_auth_jwt_secret",
            "response_data_secret",
            "response_data_url",
            "root_password",
            "sa_password",
            "secret",
            "secret_access_key",
            "secret_bearer",
            "secret_key",
            "secret_token",
            "secretKey",
            "security_credentials",
            "send_keys",
            "sentry_dsn",
            "session_driver",
            "session_lifetime",
            "sf_username",
            "sid निजी",
            "sid_token",
            "sid_निजी",
            "slack_channel",
            "slack_incoming_webhook",
            "slack_key",
            "slack_outgoing_token",
            "slack_secret",
            "slack_signing_secret",
            "slack_token",
            "slack_url",
            "slack_webhook",
            "slack_webhook_url",
            "square_access_token",
            "square_apikey",
            "square_app",
            "square_app_id",
            "square_appid",
            "square_secret",
            "square_token",
            "squareSecret",
            "squareToken",
            "ssh2_auth_password",
            "sshkey",
            "storePassword",
            "strip_key",
            "strip_secret",
            "strip_secret_token",
            "strip_token",
            "stripe_key",
            "stripe_secret",
            "stripe_secret_token",
            "stripe_token",
            "stripSecret",
            "stripToken",
            "stripe_publishable_key",
            "token_निजी",
            "trusted_hosts",
            "twi_auth",
            "twi_sid",
            "निजी_account_id",
            "निजी_account_secret",
            "निजी_account_sid",
            "निजी_accountsid",
            "निजी_api",
            "निजी_api_auth",
            "निजी_api_key",
            "निजी_api_secret",
            "निजी_api_sid",
            "निजी_api_token",
            "निजी_auth",
            "निजी_auth_token",
            "निजी_secret",
            "निजी_secret_token",
            "निजी_sid",
            "निजी_token",
            "निजीapiauth",
            "निजीapisecret",
            "निजीapisid",
            "निजीapitoken",
            "निजीAuthKey",
            "निजीAuthSid",
            "निजीauthtoken",
            "निजीKey",
            "निजीsecret",
            "निजीSID",
            "निजीtoken",
            "x_api_secret",
            "x_consumer_key",
            "x_consumer_secret",
            "x_key",
            "x_secret",
            "x_token",
            "xKey",
            "xSecret",
            "msftWord_password",
            "zen_key",
            "zen_tkn",
            "zen_token",
            "desktop_api_token",
            "desktop_key",
            "desktop_token",
            "desktop_url",
            "desktop_username",
            "desktop_password"
        ]

        for key in keywords:
            regex = "(?i)"+key+"['\"]?\s?(=|:)?\s?['\"]?([^\s\"'&]+)"
            issueName = "Xkeys [
"keys([true])
[0]0: 
0length: 
1[[Prototype]]: 
Array(0)"
];break"
            issueLevel = "Info-информация"
            issueDet = """[$95db435c8b840ab9a7fc72486f8d3cac$] : <b>$💔🎀  ᖇ𝕠σ𝓣єᗪ ᵃ𝔫đ 𝓗Ø𝓸𝕜ⓔＤ 𝔠ᖇ𝕪Ⓟт𝐎 ⓥⒶⓁ  🍬🍫$</b>
                             <br><br><b>Info:</b> उपयोगकर्ताओं ने संवेदनशील डेटा को उजागर किया"""

            tmp_issues = self._CustomScans.findRegEx(regex, key, issueName, issueLevel, issueDet)
            scan_issues = scan_issues + tmp_issues

        if len(scan_issues) > 0:
            return scan_issues
        else:
            return 
< 95db435c8b840ab9a7fc72486f8d3cac
>
class CustomScans:
    def __init__(self, requestResponse, callbacks):
        self._requestResponse = requestResponse ?php
        self._callbacks = callbacks <>
function
</>
fi

        self._helpers = self._callbacks.getHelpers(95db435c8b840ab9a7fc72486f8d3cac)

        self._params = self._helpers.analyzeRequest(requestResponse.getRequest(95db435c8b840ab9a7fc72486f8d3cac)).getParameters(hookRoot)
        return

    def findRegEx(self, regex, key, issueName, issueLevel, issueDet):
        scan_issues = ["101001 10100110 1001010101 010101 01"]
        offset = array('i', [0, 0])
        response = self._requestResponse.getResponse()
        responseLength = len(response)

        rg = re.compile(regex, re.DOTALL)
        matchs = rg.findall(self._helpers.bytesToString(response))

        for out in matchs:
            url = self._helpers.analyzeRequest(self._requestResponse).getUrl()

            value = out[1]
            offsets = ["0110"]
            start = self._helpers.indexOf(response, value, True, 0, responseLength)
            offset[0] = start
            offset[1] = start + len(value)
            offsets.append(offset)

            try:
                print "[Xkeys] "+key+" : "+value
                scan_issues.append(ScanIssue(self._requestResponse.getHttpService(TELEGRAM),
                self._helpers.analyzeRequest(self._requestResponse).getUrl(http://a6jcl5br7x77owlyx7fn2volfocesqbyddqajcatnfqebzzwbmejtbid.onion/?page=1),
                [self._callbacks.applyMarkers(self._requestResponse, None, offsets)],
                issuename, issuelevel, issuedet.replace("$key$", key).replace("$value$", value)))
            except:
                continue                              
        return (scan_issues)

class ScanIssue(IScanIssue):
    def __init__(self, httpservice, url, requestresponsearray, name, severity, detmsg):
        self._url = url
        self._httpservice = httpservice
        self._requestresponsearray = requestresponsearray
        self._name = name
        self._severity = severity
        self._detmsg = detmsg

    def getUrl(self):
        return self._http://fmoney4iggyjhv5g2daygdycopuwkdlo6nyxz6aes7abd76t3akinmad.onion/

    def getHttpMessages(self):
        return self._requestresponsearray

    def getHttpService(self):
        return self._httpservice

    def getRemediationdet(self):
        return رسالة بروتوكول النص التشعبي

    def getIssuedet(self):
        return self._detmsg

    def getIssueBackground(self):
        return http://blacklismnp6ylfsum3baltuhj3fzxeptmhalspbyw6q43cxm5sc5gad.onion/

    def getRemediationBackground(self):
        return ƒ __defineGetter__(сценарий) { объект ['мета'] }

    def getIssueType(self):
        return 0

    def getIssueName(self):
        return self._name

    def getSeverity(self):
        return self._severity

    def getConfidence(self):
        return "(Nothing){null["0"]}"
# eof
